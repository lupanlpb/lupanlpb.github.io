{"meta":{"title":"Zhuanghua","subtitle":"认清自己","description":"一只USTC菜鸟","author":"Zhuanghua","url":"http://yoursite.com","root":"/"},"pages":[{"title":"tags","date":"2019-05-26T15:05:51.000Z","updated":"2019-05-26T15:06:14.801Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-05-26T15:07:00.000Z","updated":"2019-05-26T15:07:33.201Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-05-26T15:02:27.000Z","updated":"2019-05-26T15:32:20.430Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"关于我男，USTC 固体地球物理学硕士在读，典型菜鸟。"}],"posts":[{"title":"数据结构与算法(Python)","slug":"数据结构与算法-Python","date":"2019-07-10T14:39:37.000Z","updated":"2019-07-13T02:46:04.979Z","comments":true,"path":"2019/07/10/数据结构与算法-Python/","link":"","permalink":"http://yoursite.com/2019/07/10/数据结构与算法-Python/","excerpt":"栈 栈(stack)是一个项的有序集合，添加项和移除项都发生在同一端，这个端称为“顶”，另一端称为“底”。后添加的项会被首先移除，这种排序原则称为后进先出(LIFO)。 栈操作","text":"栈 栈(stack)是一个项的有序集合，添加项和移除项都发生在同一端，这个端称为“顶”，另一端称为“底”。后添加的项会被首先移除，这种排序原则称为后进先出(LIFO)。 栈操作 stack()：创建一个新的空栈 stack.is_empty()：判断是否为空 stack.push(item)：元素入栈 stack.peek()：元素出栈(不删除栈顶元素) stack.size()：栈的大小 stack.pop()：元素出栈(删除栈顶元素) Python实现栈12345678910111213141516171819202122232425# python list实现栈class Stack(): def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def push(self, item): self.items.append(item) def peek(self): if self.isEmpty(): return \"The stack is empty!\" else: return self.items[-1] def size(self): return len(self.items) def pop(self): if self.isEmpty(): return \"The stack is empty!\" else: return self.items.pop() 队列 队列(queue)是一系列有顺序的元素的集合，新元素的加入在队列的“队尾”(rear)，元素的移除发生在队列的“队首”(front)。这种排序原则叫做先进先出(FIFO)。 队列操作 queue.queue()：创建一个空队列 queue.enqueue(item)：添加元素到队尾 queue.dequeue()：从队首移除元素 queue.isEmpty()：判断队列是否为空 queue.size()：队列大小 Python实现队列12345678910111213141516171819# python list实现队列class Queue(): def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def enqueue(self, item): self.items.insert(0, item) def dequeue(self): if self.isEmpty(): return \"The queue is empty!\" else: return self.items.pop() def size(self): return len(self.items) 双端队列 双端队列(deque, double-ended queue)也是一系列元素的有序集合，其两端分别称为队首(front)和队尾(rear)。元素可以从两端插入，也可以从两端删除，兼具栈和队列的所有功能。 双端队列操作 Deque()：创建双端队列 addFront(item)：在队首插入元素 addRear(item)：在队尾插入元素 rmFront()：从队首移除元素 rmRear()：从队尾移除元素 isEmpty()：判断双端队列是否为空 size()：返回双端队列的大小 Python list实现双端队列123456789101112131415161718192021222324252627class Deque(): def __init__(self): self.items = [] def isEmpty(self): return self.items == [] def addFront(self, item): self.items.append(item) def addRear(self, item): self.items.insert(0, item) def rmFront(self): if self.isEmpty(): return \"The deque is empty!\" else: return self.items.pop() def rmRear(self): if self.isEmpty(): return \"The deque is empty!\" else: return self.items.pop(0) def size(self): return len(self.items) 无序列表 无序列表由一个节点集合组成，每个节点采用显式引用链接到下一个节点。 无序列表操作 unorderedList() add() remove() search() isEmpty() size() append() index(item) insert(pos, item) pop() pop(pos)无序列表实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132# python实现无序列表# Node 类class Node(): def __init__(self, element): self.data = element self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newelement): self.data = newelement def setNext(self, newnext): self.next = newnext# 无序列表类class unorderedList(): # unorderedList要保持对列表头一个节点的引用 def __init__(self): self.head = None # 判断无序列是否为空，即列表头是否指向None def isEmpty(self): return self.head == None # 添加add()方法 def add(self, item): newNode = Node(item) newNode.setNext(self.head) self.head = newNode # 添加size()方法，此过程需要遍历无序列表 def size(self): current = self.head count = 0 while current != None: count += 1 current = current.getNext() return count # 添加search方法 def search(self, item): current = self.head found = False while current != None and not found: if current.getData() == item: found = True else: current = current.getNext() return found # 添加remove()方法 def remove(self, item): if not self.search(item): return \"The unorderedList don't contain this item!\" previous = None current = self.head found = False while not found: if current.getData() == item: found = True else: previous = current current = current.getNext() # 要删除的节点为第一个节点 if previous == None: self.head = current.getNext() else: previous.setNext(current.getNext()) # 添加append()方法 def append(self, item): newNode = Node(item) if self.head == None: newNode.setNext(self.head) self.head = newNode else: previous = None current = self.head while current != None: previous = current current = current.getNext() previous.setNext(newNode) # 添加index()方法 def index(self, item): current = self.head count = -1 while current != None: count += 1 if current.getData() == item: return count current = current.getNext() # 添加pop()方法 def pop(self): previous = None current = self.head while current != None: previous = current current = current.getNext() previous.setNext(None) return previous.data # 添加insert()方法 def insert(self, pos, item): newNode = Node(item) previous = None current = self.head for i in range(pos): previous = current current = current.getNext() # in case of pos = 0 if previous == None: newNode.setNext(self.head) self.head = newNode else: previous.setNext(newNode) newNode.setNext(current) # traverse the unorderedList def println(self): current = self.head lists = [] while current != None: lists.append(current.data) current = current.getNext() print(lists) 有序列表 有序列表中元素是按照从小到大顺序排列的。当我们考虑有序列表时，我们应该可以注意到isEmpty和size方法的实现和无序列表 相同，因为它们只处理列表中节点的数量而不考虑节点的实际值。需要改变的是index，remove，search和add，因为有序列表的有序性，当我们搜索到的节点值大于target时，即表示当前值不存在。 有序列表操作 orderedList() add() remove() search() isEmpty() size() index(item) pop() pop(pos)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138# python实现有序列表# Node 类class Node(): def __init__(self, element): self.data = element self.next = None def getData(self): return self.data def getNext(self): return self.next def setData(self, newelement): self.data = newelement def setNext(self, newnext): self.next = newnext# 无序列表类class orderedList(): # unorderedList要保持对列表头一个节点的引用 def __init__(self): self.head = None # 判断链表是否为空，即列表头是否指向None def isEmpty(self): return self.head == None # 添加add()方法 def add(self, item): previous = None current = self.head stop = False while current != None and not stop: if current.getData() &gt; item: stop = True else: previous = current current = current.getNext() newNode = Node(item) if previous == None: newNode.setNext(self.head) self.head = newNode else: newNode.setNext(current) previous.setNext(newNode) # 添加size()方法，此过程需要遍历链表 def size(self): current = self.head count = 0 while current != None: count += 1 current = current.getNext() return count # 添加search方法 def search(self, item): current = self.head found = False stop = False while current != None and not found and not stop: if current.getData() == item: found = True else: if current.getData() &gt; item: stop = True else: current = current.getNext() return found # 添加remove()方法 def remove(self, item): if not self.search(item): return \"The unorderedList don't contain this item!\" previous = None current = self.head found = False while not found: if current.getData() == item: found = True else: previous = current current = current.getNext() # 要删除的节点为第一个节点 if previous == None: self.head = current.getNext() else: previous.setNext(current.getNext()) # 添加index()方法 def index(self, item): current = self.head count = -1 while current != None: count += 1 if current.getData() == item: return count current = current.getNext() return None # 添加pop()方法 def pop(self): previous = None current = self.head while current != None: previous = current current = current.getNext() previous.setNext(None) return previous.data # 添加insert()方法 def insert(self, pos, item): newNode = Node(item) previous = None current = self.head for i in range(pos): previous = current current = current.getNext() # in case of pos = 0 if previous == None: newNode.setNext(self.head) self.head = newNode else: previous.setNext(newNode) newNode.setNext(current) # traverse the unorderedList def println(self): current = self.head lists = [] while current != None: lists.append(current.data) current = current.getNext() print(lists) 链表的分析：当分析链表方法的复杂度时，我们应该考虑它们是否需要遍历链表。考虑一个有 n 个节点的链 表，isEmpty 方法复杂度是 O（1），因为它只需要检查链表的头指针是否为 None。对于方法 size， 则总需要 n 个步骤，因为除了遍历整个链表以外，没有办法知道链表的节点数。因此，size 方法的复 杂度是 O（n）。无序列表的 add 方法的复杂度是 O（1），因为我们永远只需要在链表的头部简单 地添加一个新的节点。但是，search、remove 和在有序列表中的 add 方法，需要遍历。尽管在平均 情况下，它们可能只需要遍历一半的节点，但这些方法的复杂度都是 O(n)，因为在最糟糕的情况下 需要遍历整个链表。你可能还注意到，这些方法的实现性能与 Python 的内置列表 list 不同，这表明 Python 中的 list 不是这么实现的。实际上，Python 中的列表的实现是基于数组的。 持续更新中…","categories":[],"tags":[{"name":"Data Structure","slug":"Data-Structure","permalink":"http://yoursite.com/tags/Data-Structure/"},{"name":"Algorithm","slug":"Algorithm","permalink":"http://yoursite.com/tags/Algorithm/"},{"name":"Stack","slug":"Stack","permalink":"http://yoursite.com/tags/Stack/"},{"name":"Queue","slug":"Queue","permalink":"http://yoursite.com/tags/Queue/"},{"name":"dequeue","slug":"dequeue","permalink":"http://yoursite.com/tags/dequeue/"},{"name":"unorderedList","slug":"unorderedList","permalink":"http://yoursite.com/tags/unorderedList/"},{"name":"orderedList","slug":"orderedList","permalink":"http://yoursite.com/tags/orderedList/"}]},{"title":"conda常用命令总结","slug":"conda常用命令总结","date":"2019-07-10T13:59:58.000Z","updated":"2019-07-10T14:33:44.544Z","comments":true,"path":"2019/07/10/conda常用命令总结/","link":"","permalink":"http://yoursite.com/2019/07/10/conda常用命令总结/","excerpt":"Conda是一个开源跨平台的包管理以及环境管理系统。它可以快速地安装、运行和更新软件包及其依赖，并很简单的创建、克隆、切换、清除虚拟环境","text":"Conda是一个开源跨平台的包管理以及环境管理系统。它可以快速地安装、运行和更新软件包及其依赖，并很简单的创建、克隆、切换、清除虚拟环境 环境管理1234567conda info -e # 查看当前已经安装的环境,当前激活的环境会显示一个'*',不同环境都在目录$HOME/.anaconda/envs下conda create --name python37 python=3.7 # 创建python37环境，python版本为3.7，但是此时仅安装python3.7的必须项(如python, pip等)， 如果希望该环境像默认环境一样，需要执行conda install anacondaconda activate python37 # 激活环境(conda4.4以前的版本为source activate python37)conda deactivate python37 # 返回base环境conda remove --name python37 --all # 删除已有环境conda create -n flowers --clone snowflakes # 通过克隆snowfllakes来创建一个称为flowers的副本conda info -envis # 确认当前环境 包管理123456789101112conda install numpy # 安装numpyconda list # 用于查看当前环境下各种方式安装的包conda list -n python37 # 用于查看指定环境下已安装的包conda search numpy # 查看包信息conda install -n python37 numpy # 安装在指定环境conda update -n python37 numpy # 更新指定环境下的包conda remove -n python37 numpy # 删除特定环境下的包conda update conda # 更新condaconda update anaconda # 更新anacondaconda update python # 更新pythonconda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free/ # 添加anaconda镜像conda config --set show_channel_urls yes # 设置搜索时显示通道地址","categories":[],"tags":[{"name":"Anaconda","slug":"Anaconda","permalink":"http://yoursite.com/tags/Anaconda/"},{"name":"conda","slug":"conda","permalink":"http://yoursite.com/tags/conda/"}]},{"title":"Navicat 连接 Mysql 8.0.16报错解决","slug":"Navicat-连接-Mysql-8-0-16报错解决","date":"2019-07-08T12:21:13.000Z","updated":"2019-07-08T12:29:44.265Z","comments":true,"path":"2019/07/08/Navicat-连接-Mysql-8-0-16报错解决/","link":"","permalink":"http://yoursite.com/2019/07/08/Navicat-连接-Mysql-8-0-16报错解决/","excerpt":"错误提示：Client does not support authentication protocol requested by server; consider upgrading MySQL client","text":"错误提示：Client does not support authentication protocol requested by server; consider upgrading MySQL client 问题出现原因MySQL8.0与MySQL5.0所采用的加密方式规则不一样，所以导致Navicat打不开。可通过select host, user, authentication_string, plugin from user;查看密码的规则。root用户的加密规则默认的是：caching_sha2_password，所以我们只需要将默认的caching_sha2_password改为mysql_native_password即可。 解决方法123mysql -u root -p，输入密码ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY 'yourpassword';FLUSH PRIVILEGES;","categories":[],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://yoursite.com/tags/MySQL/"},{"name":"Navicat","slug":"Navicat","permalink":"http://yoursite.com/tags/Navicat/"}]},{"title":"SQL学习笔记","slug":"SQL学习笔记","date":"2019-07-08T08:41:40.000Z","updated":"2019-07-13T08:49:56.381Z","comments":true,"path":"2019/07/08/SQL学习笔记/","link":"","permalink":"http://yoursite.com/2019/07/08/SQL学习笔记/","excerpt":"什么是SQLSQL是用于访问和处理数据库的标准的计算机语言 结构化查询语言，全称是structured Query Language 可以访问和处理数据库 是ANSI标准的计算机语言 除了SQL标准之外， 大部分SQL数据库程序都拥有它们自己的专有扩展","text":"什么是SQLSQL是用于访问和处理数据库的标准的计算机语言 结构化查询语言，全称是structured Query Language 可以访问和处理数据库 是ANSI标准的计算机语言 除了SQL标准之外， 大部分SQL数据库程序都拥有它们自己的专有扩展 关系数据库 关系数据库 = 多张表 + 各表之间的关系表的结构 表名 列和列名 行 主键：标注数据唯一性各表之间的关系 联结数据库的数据类型 字符型 数字 日期SQL分类1. DDL(数据定义语言) create: 创建数据库和表 drop: 删除数据库和表 alter: 修改数据库和表的结构如：1234567create table students(学号 varchar(20),姓名 varchar(20) not null,出生日期 date not null,性别 varchar(20) not null,primary key(学号)); 2. DML(数据操作语言) insert into: 向表中插入数据 delete: 删除表中的数据 select: 查询表中的数据 update: 修改表中的数据3. DCL(数据控制语言) commit: 确认对数据库中的数据进行的变更 rollback: 取消对数据库中的数据进行的变更 crant: 赋予用户操作的权限SQL语句书写规则 SQL语句以英文分号”;”结尾 SQL语句不区分关键字的大小写 输入字符的时候只能使用英文字符如：1insert into student (学号,姓名,出生日期,性别) values ('0001','小明', '2000-06-06', '男'); 常用命令及例句12345678910111213141516171819202122232425262728293031323334353637383940-- 常用命令create databases -- 创建新数据库alter databases -- 修改数据库create table -- 创建新表alter table -- 更改数据库表drop table -- 删除数据表create index -- 创建索引drop index -- 删除索引select -- 提取数据update -- 更新数据delete -- 删除数据insert into -- 插入数据-- 例句use school; -- 选择数据库set name utf8; -- 设置使用的字符集select * from school.student; -- 读取数据表信息select 学号,姓名 from student;select distinct column_name, column_name from table_name; -- 仅列出不相同的值select column_name, column_name from table_name where 性别='男'; -- 用于提取那些满足指定条件的记录，如提取所有男生信息Select * from emp where sal &gt; 2000 and sal &lt; 3000;Select * from emp where sal &gt; 2000 or comm &gt; 500;select * from emp where not sal &gt; 1500;Select * from emp where comm is null;Select * from emp where sal between 1500 and 3000;Select * from emp where sal in (5000,3000,1500);Select * from emp where ename like 'M%';select column_name, column_namefrom table_nameorder by column_name, column_name ASC|DESC; -- 对提取结果排序(DESC降序排列)insert into table_namevalues (value1, value2, value3, ...); -- 向表中插入数据insert into table_name (column1, column2, ...)values (value1, value2, ...); -- 指定列插入数据update table_nameset column1=value1, column2=value2where name='xxx'; -- 当名字为'xxx'时，更新该两列数值，执行update时一定要仔细检查where条件delete from table_namewhere some_column=some_value; -- 根据where条件删除数据，执行delete时一定要仔细检查where条件delete from table_name; -- 删除表中所有行，但表结构、属性、索引不变，表还在delete * from tabel_name; -- 删除表中所有行，但表结构、属性、索引不变，表还在 补充： 持续更新中…","categories":[],"tags":[{"name":"SQL","slug":"SQL","permalink":"http://yoursite.com/tags/SQL/"}]},{"title":"Logistic Regression","slug":"Logistic-Regression","date":"2019-06-14T04:42:32.000Z","updated":"2019-06-14T06:20:08.230Z","comments":true,"path":"2019/06/14/Logistic-Regression/","link":"","permalink":"http://yoursite.com/2019/06/14/Logistic-Regression/","excerpt":"在分类问题中，要预测的 $y$ 值离散的，逻辑回归是目前最流行使用最广泛的一种用于分类的学习算法。 Hypothesis 分类：$y = 0\\ or\\ 1$ 在逻辑回归中，$0\\ &lt;\\ h_\\theta\\ &lt;1 $， $h_\\theta = g(\\theta^TX)$，其中$X$ 表示特征向量，$g(z)=\\frac{1}{1+e^{-z}}$ 是一个常用的S型$(Sigmoid Function)$ 逻辑函数。","text":"在分类问题中，要预测的 $y$ 值离散的，逻辑回归是目前最流行使用最广泛的一种用于分类的学习算法。 Hypothesis 分类：$y = 0\\ or\\ 1$ 在逻辑回归中，$0\\ &lt;\\ h_\\theta\\ &lt;1 $， $h_\\theta = g(\\theta^TX)$，其中$X$ 表示特征向量，$g(z)=\\frac{1}{1+e^{-z}}$ 是一个常用的S型$(Sigmoid Function)$ 逻辑函数。 12345678910111213141516171819202122import numpy as np# sigmoid functiondef sigmoidFunc(z): return 1.0 / (1.0 + np.exp(-z))# set axesdef originset(): ax = plt.gca() ax.spines['right'].set_color('none') ax.spines['top'].set_color('none') ax.xaxis.set_ticks_position('bottom') ax.yaxis.set_ticks_position('left') ax.spines['bottom'].set_position(('data', 0)) ax.spines['left'].set_position(('data', 0))originset()z = np.arange(-10, 10, 0.1)plt.plot(x, sigmoidFunc(x), 'b')plt.yticks(np.arange(0.2, 1.2, 0.2))plt.title('$Sigmoid\\ Function$') 对$h_\\theta$ 的理解： 在逻辑回归中，当$h_\\theta(x) &gt;= 0.5$ 时，$y = 1$；当$h_\\theta(x) &lt; 0.5$ 时，$y = 0$。 对于一个输入，根据选定的参数计算输出变量为1的可能性，即$h_{\\theta}(x)=P(y=1 | x ; \\theta)$。例如，如果对于给定的$x$，通过已经确定的参数计算得出$h_\\theta(x) = 0.7$，则表示有$70\\%$ 的几率$y$ 为正向类，相应地$y$ 为负向类的几率为$1-0.7=0.3$。 Cost Function 对于线性回归，可以使用模型误差的平方和作为代价函数$J(\\theta)$，在此基础上最小化$J(\\theta)$ 以求得$\\theta $，此时的代价函数是一个凸函数，没有局部最小值，可以很容易的找到全局最小值。但对于逻辑回归模型来说，若按照这样的思路来定义代价函数，此时的代价函数是非凸函数，有就很多的局部极小值，不利于梯度下降法的求解。 于是需要根据逻辑回归的特征重新定义代价函数：$J(\\theta)=\\frac{1}{m} \\sum_{i=1}^{m} \\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$。其中$$\\begin{equation}\\operatorname{cost}\\left(h_{\\theta}(x), y\\right)=\\left{\\begin{aligned}-\\log \\left(h_{\\theta}(x)\\right) &amp; \\text { if } y=1 \\\\-\\log \\left(1-h_{\\theta}(x)\\right) &amp; \\text { if } y=0 \\end{aligned}\\right.\\end{equation}$$ $h_\\theta(x)$ 与$\\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$ 的关系如下图所示： 从上图可以看出$\\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$ 的特点：当$y = 1$时，$h_\\theta$ 越接近$1$，$\\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$ 越小，反之越大；当$y = 0$时，$h_\\theta$ 越接近 $0$，$\\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$ 越小，反之越大。 根据这一特点，构建$\\operatorname{cost}\\left(h_{\\theta}\\left(x^{(i)}\\right), y^{(i)}\\right)$ 如下：$\\operatorname{cost}\\left(h_{\\theta}(x), y\\right)=-y \\times \\log \\left(h_{\\theta}(x)\\right)-(1-y) \\times \\log \\left(1-h_{\\theta}(x)\\right)$。 据此可得代价函数：$J(\\theta)=\\frac{1}{m} \\sum_{i=1}^{m}\\left[-y^{(i)} \\log \\left(h_{\\theta}\\left(x^{(i)}\\right)\\right)-\\left(1-y^{(i)}\\right) \\log \\left(1-h_{\\theta}\\left(x^{(i)}\\right)\\right)\\right]$。 123456789# cost functiondef costfn(theta, X, y, mylambda = 0): term1 = np.dot(-y.T, np.log(h(theta, X))) term2 = np.dot((1 - y).T, np.log(1 - h(theta, X)))# regularized termregn = (mylambda/ (2.0 * m)) * np.sum(np.power(theta[1:], 2))return float(1.0/m * np.sum(term1 - term2) + regn) Gradient在得到代价函数之后，我们便可以利用梯度下降法来求解使代价函数最小的参数$\\theta$。 求解算法：Repeat $\\theta_{j} :=\\theta_{j}-\\alpha \\frac{\\partial}{\\partial \\theta_{j}} J(\\theta)$ and simultaneously update all $\\theta_j$ 求导后带入可得：Repeat $\\theta_{j} :=\\theta_{j}-\\alpha \\frac{1}{m} \\sum_{i=1}^{m}\\left(h_{\\theta}\\left(\\mathrm{x}^{(i)}\\right)-\\mathrm{y}^{(i)} \\quad\\right) \\mathrm{x}_{j}^{(i)} $ and simultaneously updata all $\\theta_j$ Summary主要公式： Sigmoid function: $g(z)=\\frac{1}{1+e^{-z}}$ Hypothesis: $h_\\theta = g(\\theta^TX) = g(z)=\\frac{1}{1+e^{-\\theta^TX}}$ $\\operatorname{cost}:$ $\\operatorname{cost}\\left(h_{\\theta}(x), y\\right)=-y \\times \\log \\left(h_{\\theta}(x)\\right)-(1-y) \\times \\log \\left(1-h_{\\theta}(x)\\right)$ Cost function: $J(\\theta)=\\frac{1}{m} \\sum_{i=1}^{m}\\left[-y^{(i)} \\log \\left(h_{\\theta}\\left(x^{(i)}\\right)\\right)-\\left(1-y^{(i)}\\right) \\log \\left(1-h_{\\theta}\\left(x^{(i)}\\right)\\right)\\right]$ Gradient: $\\frac{\\partial J(\\theta)}{\\partial \\theta_{j}}=\\frac{1}{m} \\sum_{i=1}^{m}\\left[h_{\\theta}\\left(x^{(i)}\\right)-y^{(i)}\\right] x_{j}^{(i)}$ Appendix：the deviation of $J (\\theta)$$$J(\\theta)=-\\frac{1}{m} \\sum_{i=1}^{m}\\left[y^{(i)} \\log \\left(h_{\\theta}\\left(x^{(i)}\\right)\\right)+\\left(1-y^{(i)}\\right) \\log \\left(1-h_{\\theta}\\left(x^{(i)}\\right)\\right)\\right]$$ 由于$h_{\\theta}\\left(x^{(i)}\\right)=\\frac{1}{1+e^{-\\theta^{T} x^{(i)}}}$，则：$$\\begin{array}{l}{y^{(i)} \\log \\left(h_{\\theta}\\left(x^{(i)}\\right)\\right)+\\left(1-y^{(i)}\\right) \\log \\left(1-h_{\\theta}\\left(x^{(i)}\\right)\\right)} \\\\ {=y^{(i)} \\log \\left(\\frac{1}{1+e^{-\\theta^{T} x^{(i)}}}\\right)+\\left(1-y^{(i)}\\right) \\log \\left(1-\\frac{1}{1+e^{-\\theta^{T} x^{(i)}}}\\right)} \\\\ {=-y^{(i)} \\log \\left(1+e^{-\\theta^{T} x^{(i)}}\\right)-\\left(1-y^{(i)}\\right) \\log \\left(1+e^{\\theta^{T} x^{(i)}}\\right)}\\end{array}$$ 所以，$$\\frac{\\partial}{\\partial \\theta_{j}} J(\\theta)=\\frac{\\partial}{\\partial \\theta_{j}}\\left[-\\frac{1}{m} \\sum_{i=1}^{m}\\left[-y^{(i)} \\log \\left(1+e^{-\\theta^{T} x^{(i)}}\\right)-\\left(1-y^{(i)}\\right) \\log \\left(1+e^{\\theta^{T} x^{(i)}}\\right)\\right]\\right]$$ $$\\begin{array}{l}{=-\\frac{1}{m} \\sum_{i=1}^{m}\\left[-y^{(i)} \\frac{-x_{j}^{(i)} e^{-\\theta^{T} x^{(i)}}}{1+e^{-\\theta^{T} x^{(i)}}}-\\left(1-y^{(i)}\\right) \\frac{x_{j}^{(i)} e^{\\theta^{T} x^{(i)}}}{1+e^{\\theta^{T} x^{(i)}}}\\right]} \\\\ {=-\\frac{1}{m} \\sum_{i=1}^{m} y^{(i)} \\frac{x_{j}^{(i)}}{1+e^{\\theta^{T} x^{(i)}}}-\\left(1-y^{(i)}\\right) \\frac{x_{j}^{(i)} e^{\\theta^{T} x^{(i)}}}{1+e^{\\theta^{T} x^{(i)}}} ]} \\\\ {=-\\frac{1}{m} \\sum_{i=1}^{m} \\frac{y^{(i)} x_{j}^{(i)}-x_{j}^{(i)} e^{\\theta^{T} x^{(i)}}+y^{(i)} x_{j}^{(i)} e^{\\theta^{T} x^{(i)}}}{1+e^{\\theta^{T} x^{(i)}}}} \\\\ {=-\\frac{1}{m} \\sum_{i=1}^{m} \\frac{y^{(i)}\\left(1+e^{\\theta^{T} x^{(i)}}\\right)-e^{\\theta^{T} x^{(i)}}}{1+e^{\\theta^{T} x^{(i)}}} x_{j}^{(i)}} \\\\ {=-\\frac{1}{m} \\sum_{i=1}^{m}\\left(y^{(i)}-\\frac{e^{\\theta^{T} x^{(i)}}}{1+e^{\\theta^{T} x^{(i)}}}\\right) x_{j}^{(i)}} \\\\ {=-\\frac{1}{m} \\sum_{i=1}^{m}\\left(y^{(i)}-\\frac{1}{1+e^{-\\theta^{T} x^{(i)}} )} x_{j}^{(i)}\\right.} \\\\ {=-\\frac{1}{m} \\sum_{i=1}^{m}\\left[y^{(i)}-h_{\\theta}\\left(x^{(i)}\\right)\\right] x_{j}^{(i)}} \\\\ {=\\frac{1}{m} \\sum_{i=1}^{m}\\left[h_{\\theta}\\left(x^{(i)}\\right)-y^{(i)}\\right] x_{j}^{(i)}}\\end{array}$$即$$\\frac{\\partial J(\\theta)}{\\partial \\theta_{j}}=\\frac{1}{m} \\sum_{i=1}^{m}\\left[h_{\\theta}\\left(x^{(i)}\\right)-y^{(i)}\\right] x_{j}^{(i)}$$","categories":[],"tags":[{"name":"机器学习","slug":"机器学习","permalink":"http://yoursite.com/tags/机器学习/"},{"name":"分类","slug":"分类","permalink":"http://yoursite.com/tags/分类/"},{"name":"逻辑回归","slug":"逻辑回归","permalink":"http://yoursite.com/tags/逻辑回归/"},{"name":"Sigmoid Function","slug":"Sigmoid-Function","permalink":"http://yoursite.com/tags/Sigmoid-Function/"},{"name":"梯度下降法","slug":"梯度下降法","permalink":"http://yoursite.com/tags/梯度下降法/"}]},{"title":"远程工具的使用","slug":"远程工具的使用","date":"2019-05-31T14:46:48.000Z","updated":"2019-05-31T14:47:20.371Z","comments":true,"path":"2019/05/31/远程工具的使用/","link":"","permalink":"http://yoursite.com/2019/05/31/远程工具的使用/","excerpt":"ssh：在同一局域网下，远程连接 安装openssh-server 1sudo apt-get install openssh-server # 安装openssh-server 远程访问","text":"ssh：在同一局域网下，远程连接 安装openssh-server 1sudo apt-get install openssh-server # 安装openssh-server 远程访问 1ifconfig # 查看远程linux系统的IP地址 在本地终端输入如下代码： 1ssh username@IP地址 进行访问 请求访问的时候会要求输入远程用户密码 vnc：在同一局域网下远程共享桌面 linux安装x11vnc 1sudo apt-get install x11vnc # 安装vnc 设置密码 1x11vnc -storepasswd # 设置密码 终端执行以下代码，进行远程共享桌面 1x11vnc -usepw # 启动远程共享桌面 samba：在同一局域网下共享文件 在远程文件目录下新建文件夹，命名为Share,然后右键选中选择”Local Network Share” 在跳出的页面中勾选Share this folder,并勾选”Allow others to creat and delete files in this folder” 在终端输入以下命令,设置密码 1sudo smbpasswd -a username # 设置密码 在Mac中按下command + 跳出如下选框 在框内输入 1smb://远程linux的IP地址 然后输入用户名及密码，进行访问。","categories":[],"tags":[{"name":"ssh","slug":"ssh","permalink":"http://yoursite.com/tags/ssh/"},{"name":"vnc","slug":"vnc","permalink":"http://yoursite.com/tags/vnc/"},{"name":"smb","slug":"smb","permalink":"http://yoursite.com/tags/smb/"},{"name":"远程工具","slug":"远程工具","permalink":"http://yoursite.com/tags/远程工具/"}]},{"title":"git学习笔记","slug":"git学习笔记","date":"2019-05-31T14:45:51.000Z","updated":"2019-07-13T08:48:03.924Z","comments":true,"path":"2019/05/31/git学习笔记/","link":"","permalink":"http://yoursite.com/2019/05/31/git学习笔记/","excerpt":"Git的三个工作区域 工作区 暂存区 Git仓库","text":"Git的三个工作区域 工作区 暂存区 Git仓库 Git提交文件常用命令12345678git config --list # 查看配置列表git config --global user.email 'lupanlpb@163.com' # 配置邮箱git config --global user.name 'lupanlpb' # 配置用户名git clone https://github.com/lupanlpb/GitLearn.git # 克隆远程仓库到本地git status # 查看状态git add test.dat # 将文件从工作区提交到暂存区git commit -m \"提交的描述\" # 将文件从暂存区提交到Git仓库git push # 提交到远程仓库 持续更新中…","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"}]},{"title":"Mac下利用Hexo搭建个人博客","slug":"Mac下利用Hexo搭建个人博客","date":"2019-05-31T14:44:44.000Z","updated":"2019-05-31T14:45:24.223Z","comments":true,"path":"2019/05/31/Mac下利用Hexo搭建个人博客/","link":"","permalink":"http://yoursite.com/2019/05/31/Mac下利用Hexo搭建个人博客/","excerpt":"1. 安装git2. 安装node.js3. 安装cnpm","text":"1. 安装git2. 安装node.js3. 安装cnpm 1234sudo su # 切换到root用户npm -v # 查看node.js是否安装成功npm install -g cnpm --registry=https://registry.npm.taobao.org #安装镜像cnpm -v # 查看安装cnpm是否成功 4. 安装hexo12cnpm install -g hexo-cli # 安装hexohexo -v # 查看是否安装成功 5. 创建博客12345678910111213mkdir blog # 博客目录cd blog # 切换到blog目录sudo hexo init # 初始化博客hexo s #启动博客，在浏览器输入localhost:4000hexo n \"My first blog\" # 新建一篇博客文章cd source/_posts/ # 切换目录vim My-first-blog.md # 编辑博客cd ../../ # 切换到blog目录hexo clean # 清理hexo g # 生成博客hexo s # 启动# 到目前为止，博客已经搭建完毕# 下面将博客部署到github 6. 部署博客到github1234567891011121314151617# 1. 登录github# 2. 新建仓库# 3. 在repository name输入你的github昵称 + github.io, 如\"lupanlpb.github.io”# 4. 在description输入介绍信息# 5. 点击create# 6. 安装git部署插件cnpm install --save hexo-deployer-git # 安装过程会报出warning，可不予理会# 7. 修改配置文件vim _config.yml ## 8. 在 Deployment处修改type、reporepo和branch如下deploy: type: git repo: https://github.com/lupanlpb/lupanlpb.github.io.git branch: master# 保存退出# 9. 部署到远端hexo d # 部署，并根据提示输入github账号和密码 现在可以访问https://lupanlpb.github.io/了，这样博客就部署到github了！ 7. 更换主题 推荐使用Even123456git clone https://github.com/litten/hexo-theme-yilia.git themes/yilia # 下载主题，在blog/themes目录下vim _config.yml # 修改配置文件将theme: landscape改为theme: yilia,保存退出hexo cleanhexo ghexo shexo d # 部署到远端","categories":[],"tags":[{"name":"git","slug":"git","permalink":"http://yoursite.com/tags/git/"},{"name":"hexo","slug":"hexo","permalink":"http://yoursite.com/tags/hexo/"},{"name":"Mac","slug":"Mac","permalink":"http://yoursite.com/tags/Mac/"},{"name":"github","slug":"github","permalink":"http://yoursite.com/tags/github/"},{"name":"Even","slug":"Even","permalink":"http://yoursite.com/tags/Even/"},{"name":"个人博客","slug":"个人博客","permalink":"http://yoursite.com/tags/个人博客/"}]},{"title":"Hello World","slug":"hello-world","date":"2019-05-26T15:37:19.240Z","updated":"2019-05-26T15:37:19.240Z","comments":true,"path":"2019/05/26/hello-world/","link":"","permalink":"http://yoursite.com/2019/05/26/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post 1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"}]}]}